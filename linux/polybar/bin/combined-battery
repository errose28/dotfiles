#!/usr/bin/env python3

from __future__ import annotations
import os
import sys
import time
import subprocess
from typing import List

# Icons listed from empty to full.
# Icons are taken from material design icons pack in the fonts dotfiles package.
CHARGING_ICONS = ["", "", "", "", "", "", "", "", "", ""]
DISCHARGING_ICONS = ["", "", "", "", "", "", "", "", "", ""]
# Once the battery reaches this point, it is considered fully charged.
FULL_CHARGE_PERCENT = 98
WARNING_PERCENT = 10

# Created to note that the user has been warned about the current low battery level.
# Deleted when the battery is not at the critical level.
WARNING_FILE = '/tmp/combined-battery-warned'

def percent() -> int:
    """
    Returns the percentage full the battery is as an int, with no percent sign.
    """

    percent_str = cmd_line_value(['ibam', '--seconds', '--percentbattery'], 0)

    # Only return the integer percent, not the sign or white space.
    for part in percent_str.split():
        if part.isdigit():
            return int(part)

def icon() -> int:
    index = percent() // len(CHARGING_ICONS)
    # If batteries are at 100%, need to clamp index from 10 to 9 so its in bounds.
    index = max(0, min(index, 9))

    if is_charging():
        bat_icon = CHARGING_ICONS[index]
    else:
        bat_icon = DISCHARGING_ICONS[index]

    return bat_icon

def is_charging() -> bool:
    return cmd_output(['cat', '/sys/class/power_supply/AC/online']) == '1'

def time_message() -> str:
    seconds = cmd_line_value(['ibam', '--seconds', '--percentbattery'], 2)
    seconds = int(seconds)

    format_str = "%H:%M"

    # Determine whether we need days on the time, or just hours and minutes.
    if seconds >= (60 ** 3) * 24:
        format_str = "%d" + format_str

    time_str = time.strftime(format_str, time.gmtime(seconds))

    if is_charging():
        if percent() >= FULL_CHARGE_PERCENT:
            # TODO: Need to get the second line, not the third, for this information.
            result = 'Fully Charged, ' + time_str + ' Estimated Life'
        else:
            result = time_str + ' Until Full'
    else:
        result = time_str + ' Remaining'

    return result

def cmd_line_value(cmd: List[str], line_num: int) -> str:
    """
    Runs cmd, captures the output of line line_num (0 based index), and returns all output after the first : with whitespace trimmed off the ends.
    """
    all_output = cmd_output(cmd)
    line = all_output.split(sep='\n')[line_num]

    return line.split(':')[1].strip()

def cmd_output(cmd: List[str]) -> str:
    return subprocess.Popen(cmd, stdout=subprocess.PIPE).communicate()[0].decode().strip()

def warn_if_needed(percentage: int) -> None:
    is_warning_file = os.path.isfile(WARNING_FILE)

    if percentage <= WARNING_PERCENT and not is_warning_file:
        cmd_output(['dunstify', '-u', 'critical', 'LOW BATTERY: ' + str(percentage) + '%'])
        # Create, open, then close the file so no new notifications are posted
        #   until the battery crosses above then below the threshold.
        with open(WARNING_FILE, 'w') as _: pass
    elif percentage > WARNING_PERCENT and is_warning_file:
        os.remove(WARNING_FILE)

def main():
    # Add -v flag to get time estimate.
    show_time_remaining = (len(sys.argv) == 2) and (sys.argv[1] == '-v')

    # TODO: Add a flag to optionally post notifications.
    percentage = percent()
    warn_if_needed(percentage)

    result = "{0}{1:>3}%".format(icon(), percent())

    if show_time_remaining:
        result += ' ' + time_message()

    print(result)

if __name__ == '__main__':
    main()
